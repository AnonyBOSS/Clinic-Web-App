{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ahmad/Downloads/ClincsManagmentSystem/lib/db/connection.ts"],"sourcesContent":["import mongoose from 'mongoose';\r\n\r\nconst MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/clinics-booking';\r\n\r\nif (!MONGODB_URI) {\r\n  throw new Error('Please define the MONGODB_URI environment variable inside .env.local');\r\n}\r\n\r\nlet cached = global as any;\r\n\r\nif (!cached.mongoose) {\r\n  cached.mongoose = { conn: null, promise: null };\r\n}\r\n\r\nexport async function connectDB() {\r\n  if (cached.mongoose.conn) {\r\n    return cached.mongoose.conn;\r\n  }\r\n\r\n  if (!cached.mongoose.promise) {\r\n    const opts = {\r\n      bufferCommands: false,\r\n    };\r\n\r\n    cached.mongoose.promise = mongoose\r\n      .connect(MONGODB_URI, opts)\r\n      .then((mongoose) => {\r\n        return mongoose;\r\n      });\r\n  }\r\n\r\n  try {\r\n    cached.mongoose.conn = await cached.mongoose.promise;\r\n  } catch (e) {\r\n    cached.mongoose.promise = null;\r\n    throw e;\r\n  }\r\n\r\n  return cached.mongoose.conn;\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW,IAAI;AAE/C;;AAIA,IAAI;AAEJ,IAAI,CAAC,OAAO,QAAQ,EAAE;IACpB,OAAO,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAChD;AAEO,eAAe;IACpB,IAAI,OAAO,QAAQ,CAAC,IAAI,EAAE;QACxB,OAAO,OAAO,QAAQ,CAAC,IAAI;IAC7B;IAEA,IAAI,CAAC,OAAO,QAAQ,CAAC,OAAO,EAAE;QAC5B,MAAM,OAAO;YACX,gBAAgB;QAClB;QAEA,OAAO,QAAQ,CAAC,OAAO,GAAG,oHAAQ,CAC/B,OAAO,CAAC,aAAa,MACrB,IAAI,CAAC,CAAC;YACL,OAAO;QACT;IACJ;IAEA,IAAI;QACF,OAAO,QAAQ,CAAC,IAAI,GAAG,MAAM,OAAO,QAAQ,CAAC,OAAO;IACtD,EAAE,OAAO,GAAG;QACV,OAAO,QAAQ,CAAC,OAAO,GAAG;QAC1B,MAAM;IACR;IAEA,OAAO,OAAO,QAAQ,CAAC,IAAI;AAC7B"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ahmad/Downloads/ClincsManagmentSystem/models/Appointment.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\r\n\r\nexport interface IAppointment extends Document {\r\n  patient_id: mongoose.Types.ObjectId;\r\n  doctor_id: mongoose.Types.ObjectId;\r\n  clinic_id: mongoose.Types.ObjectId;\r\n  room_id: mongoose.Types.ObjectId;\r\n  slot_id: mongoose.Types.ObjectId;\r\n  status: 'booked' | 'confirmed' | 'cancelled' | 'completed';\r\n  notes?: string;\r\n  payment: {\r\n    amount: number;\r\n    method: 'cash' | 'card';\r\n    transaction_id?: string;\r\n    status: 'pending' | 'paid' | 'refunded' | 'failed';\r\n    timestamp: Date;\r\n  };\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nconst AppointmentSchema = new Schema<IAppointment>(\r\n  {\r\n    patient_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Patient',\r\n      required: true,\r\n    },\r\n    doctor_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Doctor',\r\n      required: true,\r\n    },\r\n    clinic_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Clinic',\r\n      required: true,\r\n    },\r\n    room_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Room',\r\n      required: true,\r\n    },\r\n    slot_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Slot',\r\n      required: true,\r\n      unique: true,\r\n    },\r\n    status: {\r\n      type: String,\r\n      enum: ['booked', 'confirmed', 'cancelled', 'completed'],\r\n      default: 'booked',\r\n    },\r\n    notes: String,\r\n    payment: {\r\n      amount: {\r\n        type: Number,\r\n        required: true,\r\n      },\r\n      method: {\r\n        type: String,\r\n        enum: ['cash', 'card'],\r\n        required: true,\r\n      },\r\n      transaction_id: String,\r\n      status: {\r\n        type: String,\r\n        enum: ['pending', 'paid', 'refunded', 'failed'],\r\n        default: 'pending',\r\n      },\r\n      timestamp: {\r\n        type: Date,\r\n        default: Date.now,\r\n      },\r\n    },\r\n  },\r\n  {\r\n    timestamps: true,\r\n  }\r\n);\r\n\r\n// Create indexes for faster queries\r\nAppointmentSchema.index({ doctor_id: 1, createdAt: -1 });\r\nAppointmentSchema.index({ patient_id: 1, createdAt: -1 });\r\n\r\nexport default mongoose.models.Appointment || mongoose.model<IAppointment>('Appointment', AppointmentSchema);\r\n"],"names":[],"mappings":";;;;AAAA;;AAqBA,MAAM,oBAAoB,IAAI,mHAAM,CAClC;IACE,YAAY;QACV,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,WAAW;QACT,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,WAAW;QACT,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,SAAS;QACP,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,SAAS;QACP,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;QACV,QAAQ;IACV;IACA,QAAQ;QACN,MAAM;QACN,MAAM;YAAC;YAAU;YAAa;YAAa;SAAY;QACvD,SAAS;IACX;IACA,OAAO;IACP,SAAS;QACP,QAAQ;YACN,MAAM;YACN,UAAU;QACZ;QACA,QAAQ;YACN,MAAM;YACN,MAAM;gBAAC;gBAAQ;aAAO;YACtB,UAAU;QACZ;QACA,gBAAgB;QAChB,QAAQ;YACN,MAAM;YACN,MAAM;gBAAC;gBAAW;gBAAQ;gBAAY;aAAS;YAC/C,SAAS;QACX;QACA,WAAW;YACT,MAAM;YACN,SAAS,KAAK,GAAG;QACnB;IACF;AACF,GACA;IACE,YAAY;AACd;AAGF,oCAAoC;AACpC,kBAAkB,KAAK,CAAC;IAAE,WAAW;IAAG,WAAW,CAAC;AAAE;AACtD,kBAAkB,KAAK,CAAC;IAAE,YAAY;IAAG,WAAW,CAAC;AAAE;uCAExC,oHAAQ,CAAC,MAAM,CAAC,WAAW,IAAI,oHAAQ,CAAC,KAAK,CAAe,eAAe"}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ahmad/Downloads/ClincsManagmentSystem/models/Slot.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\r\n\r\nexport interface ISlot extends Document {\r\n  doctor_id: mongoose.Types.ObjectId;\r\n  clinic_id: mongoose.Types.ObjectId;\r\n  room_id: mongoose.Types.ObjectId;\r\n  date: Date;\r\n  time: string;\r\n  status: 'available' | 'booked';\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nconst SlotSchema = new Schema<ISlot>(\r\n  {\r\n    doctor_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Doctor',\r\n      required: true,\r\n    },\r\n    clinic_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Clinic',\r\n      required: true,\r\n    },\r\n    room_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Room',\r\n      required: true,\r\n    },\r\n    date: {\r\n      type: Date,\r\n      required: true,\r\n    },\r\n    time: {\r\n      type: String,\r\n      required: true,\r\n    },\r\n    status: {\r\n      type: String,\r\n      enum: ['available', 'booked'],\r\n      default: 'available',\r\n    },\r\n  },\r\n  {\r\n    timestamps: true,\r\n  }\r\n);\r\n\r\n// Create compound index for faster availability searches\r\nSlotSchema.index({ doctor_id: 1, clinic_id: 1, date: 1, status: 1 });\r\n\r\nexport default mongoose.models.Slot || mongoose.model<ISlot>('Slot', SlotSchema);\r\n"],"names":[],"mappings":";;;;AAAA;;AAaA,MAAM,aAAa,IAAI,mHAAM,CAC3B;IACE,WAAW;QACT,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,WAAW;QACT,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,SAAS;QACP,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,MAAM;QACJ,MAAM;QACN,UAAU;IACZ;IACA,MAAM;QACJ,MAAM;QACN,UAAU;IACZ;IACA,QAAQ;QACN,MAAM;QACN,MAAM;YAAC;YAAa;SAAS;QAC7B,SAAS;IACX;AACF,GACA;IACE,YAAY;AACd;AAGF,yDAAyD;AACzD,WAAW,KAAK,CAAC;IAAE,WAAW;IAAG,WAAW;IAAG,MAAM;IAAG,QAAQ;AAAE;uCAEnD,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAQ,QAAQ"}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ahmad/Downloads/ClincsManagmentSystem/models/Payment.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\r\n\r\nexport interface IPayment extends Document {\r\n  appointment_id: mongoose.Types.ObjectId;\r\n  patient_id: mongoose.Types.ObjectId;\r\n  doctor_id: mongoose.Types.ObjectId;\r\n  amount: number;\r\n  method: 'cash' | 'card';\r\n  transaction_id?: string;\r\n  status: 'pending' | 'paid' | 'refunded' | 'failed';\r\n  timestamp: Date;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nconst PaymentSchema = new Schema<IPayment>(\r\n  {\r\n    appointment_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Appointment',\r\n      required: true,\r\n    },\r\n    patient_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Patient',\r\n      required: true,\r\n    },\r\n    doctor_id: {\r\n      type: Schema.Types.ObjectId,\r\n      ref: 'Doctor',\r\n      required: true,\r\n    },\r\n    amount: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    method: {\r\n      type: String,\r\n      enum: ['cash', 'card'],\r\n      required: true,\r\n    },\r\n    transaction_id: String,\r\n    status: {\r\n      type: String,\r\n      enum: ['pending', 'paid', 'refunded', 'failed'],\r\n      default: 'pending',\r\n    },\r\n    timestamp: {\r\n      type: Date,\r\n      default: Date.now,\r\n    },\r\n  },\r\n  {\r\n    timestamps: true,\r\n  }\r\n);\r\n\r\n// Create index for reporting\r\nPaymentSchema.index({ timestamp: -1 });\r\n\r\nexport default mongoose.models.Payment || mongoose.model<IPayment>('Payment', PaymentSchema);\r\n"],"names":[],"mappings":";;;;AAAA;;AAeA,MAAM,gBAAgB,IAAI,mHAAM,CAC9B;IACE,gBAAgB;QACd,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,YAAY;QACV,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,WAAW;QACT,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,QAAQ;QACN,MAAM;QACN,UAAU;IACZ;IACA,QAAQ;QACN,MAAM;QACN,MAAM;YAAC;YAAQ;SAAO;QACtB,UAAU;IACZ;IACA,gBAAgB;IAChB,QAAQ;QACN,MAAM;QACN,MAAM;YAAC;YAAW;YAAQ;YAAY;SAAS;QAC/C,SAAS;IACX;IACA,WAAW;QACT,MAAM;QACN,SAAS,KAAK,GAAG;IACnB;AACF,GACA;IACE,YAAY;AACd;AAGF,6BAA6B;AAC7B,cAAc,KAAK,CAAC;IAAE,WAAW,CAAC;AAAE;uCAErB,oHAAQ,CAAC,MAAM,CAAC,OAAO,IAAI,oHAAQ,CAAC,KAAK,CAAW,WAAW"}},
    {"offset": {"line": 320, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ahmad/Downloads/ClincsManagmentSystem/lib/auth.ts"],"sourcesContent":["import jwt, { SignOptions } from 'jsonwebtoken';\r\n\r\nexport interface TokenPayload {\r\n  id: string;\r\n  email: string;\r\n  role: 'patient' | 'doctor';\r\n}\r\n\r\n// Load env secret with type safety\r\nconst secret = process.env.JWT_SECRET;\r\nif (!secret) {\r\n  throw new Error('JWT_SECRET is not set. Please define it in your environment variables.');\r\n}\r\n\r\nconst JWT_SECRET: string = secret;\r\n\r\nexport function generateToken(\r\n  payload: TokenPayload,\r\n  expiresIn: SignOptions['expiresIn'] = '30d'\r\n): string {\r\n  const options: SignOptions = { expiresIn };\r\n  return jwt.sign(payload, JWT_SECRET, options);\r\n}\r\n\r\nexport function verifyToken(token: string): TokenPayload | null {\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload;\r\n    return decoded;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function extractToken(authHeader: string | null): string | null {\r\n  if (!authHeader) return null;\r\n  const parts = authHeader.split(' ');\r\n  if (parts.length === 2 && parts[0] === 'Bearer') return parts[1];\r\n  return null;\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAQA,mCAAmC;AACnC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;AACrC,IAAI,CAAC,QAAQ;IACX,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,aAAqB;AAEpB,SAAS,cACd,OAAqB,EACrB,YAAsC,KAAK;IAE3C,MAAM,UAAuB;QAAE;IAAU;IACzC,OAAO,wLAAG,CAAC,IAAI,CAAC,SAAS,YAAY;AACvC;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,MAAM,UAAU,wLAAG,CAAC,MAAM,CAAC,OAAO;QAClC,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS,aAAa,UAAyB;IACpD,IAAI,CAAC,YAAY,OAAO;IACxB,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,IAAI,MAAM,MAAM,KAAK,KAAK,KAAK,CAAC,EAAE,KAAK,UAAU,OAAO,KAAK,CAAC,EAAE;IAChE,OAAO;AACT"}},
    {"offset": {"line": 360, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ahmad/Downloads/ClincsManagmentSystem/lib/auth-request.ts"],"sourcesContent":["import type { NextRequest } from 'next/server';\r\nimport { verifyToken, extractToken } from './auth';\r\n\r\nexport type AuthUser = {\r\n  id: string;\r\n  email: string;\r\n  role: 'patient' | 'doctor';\r\n};\r\n\r\nexport function getAuthUserFromRequest(req: NextRequest): AuthUser | null {\r\n  // 1) Try cookie first\r\n  let token = req.cookies.get('auth_token')?.value ?? null;\r\n\r\n  // 2) If no cookie, fall back to Authorization header\r\n  if (!token) {\r\n    const authHeader = req.headers.get('authorization');\r\n    token = extractToken(authHeader);\r\n  }\r\n\r\n  if (!token) return null;\r\n\r\n  const payload = verifyToken(token);\r\n  if (!payload) return null;\r\n\r\n  return payload;\r\n}\r\n"],"names":[],"mappings":";;;;AACA;;AAQO,SAAS,uBAAuB,GAAgB;IACrD,sBAAsB;IACtB,IAAI,QAAQ,IAAI,OAAO,CAAC,GAAG,CAAC,eAAe,SAAS;IAEpD,qDAAqD;IACrD,IAAI,CAAC,OAAO;QACV,MAAM,aAAa,IAAI,OAAO,CAAC,GAAG,CAAC;QACnC,QAAQ,IAAA,mKAAY,EAAC;IACvB;IAEA,IAAI,CAAC,OAAO,OAAO;IAEnB,MAAM,UAAU,IAAA,kKAAW,EAAC;IAC5B,IAAI,CAAC,SAAS,OAAO;IAErB,OAAO;AACT"}},
    {"offset": {"line": 383, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ahmad/Downloads/ClincsManagmentSystem/app/api/appointments/book/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { connectDB } from '@/lib/db/connection';\r\nimport Appointment from '@/models/Appointment';\r\nimport Slot from '@/models/Slot';\r\nimport Payment from '@/models/Payment';\r\nimport { getAuthUserFromRequest } from '@/lib/auth-request';\r\n\r\nexport async function POST(req: NextRequest) {\r\n  try {\r\n    await connectDB();\r\n\r\n    const authUser = getAuthUserFromRequest(req);\r\n\r\n    if (!authUser) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    if (authUser.role !== 'patient') {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Only patients can book appointments' },\r\n        { status: 403 }\r\n      );\r\n    }\r\n\r\n    const {\r\n      // patient_id,  // ❌ no longer trusted from client\r\n      doctor_id,\r\n      clinic_id,\r\n      slot_id,\r\n      room_id,\r\n      payment_amount,\r\n      payment_method,\r\n    } = await req.json();\r\n\r\n    if (!doctor_id || !clinic_id || !slot_id || !room_id) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Missing required fields' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Atomically update slot to prevent race conditions\r\n    const updatedSlot = await Slot.findOneAndUpdate(\r\n      { _id: slot_id, status: 'available' },\r\n      { status: 'booked' },\r\n      { new: true }\r\n    );\r\n\r\n    if (!updatedSlot) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Slot is no longer available' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Create appointment with embedded payment\r\n    const appointment = await Appointment.create({\r\n      patient_id: authUser.id, // ✅ from token, not client body\r\n      doctor_id,\r\n      clinic_id,\r\n      room_id,\r\n      slot_id,\r\n      status: 'booked',\r\n      payment: {\r\n        amount: payment_amount || 0,\r\n        method: payment_method || 'cash',\r\n        status: 'pending',\r\n        timestamp: new Date(),\r\n      },\r\n    });\r\n\r\n    // Also create a separate payment record\r\n    await Payment.create({\r\n      appointment_id: appointment._id,\r\n      patient_id: authUser.id, // ✅ from token\r\n      doctor_id,\r\n      amount: payment_amount || 0,\r\n      method: payment_method || 'cash',\r\n      status: 'pending',\r\n      timestamp: new Date(),\r\n    });\r\n\r\n    return NextResponse.json(\r\n      {\r\n        success: true,\r\n        message: 'Appointment booked successfully',\r\n        appointment,\r\n      },\r\n      { status: 201 }\r\n    );\r\n  } catch (error) {\r\n    console.error('Error booking appointment:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\nexport async function GET(req: NextRequest) {\r\n  try {\r\n    await connectDB();\r\n\r\n    const authUser = getAuthUserFromRequest(req);\r\n\r\n    if (!authUser) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    if (authUser.role !== 'patient') {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Only patients can view their appointments' },\r\n        { status: 403 }\r\n      );\r\n    }\r\n\r\n    // We ignore any patient_id query param now and always use the one from the token\r\n    const appointments = await Appointment.find({ patient_id: authUser.id })\r\n      .populate('doctor_id', 'full_name specializations')\r\n      .populate('clinic_id', 'name address')\r\n      .populate('room_id', 'room_number type')\r\n      .sort({ createdAt: -1 })\r\n      .lean();\r\n\r\n    return NextResponse.json(\r\n      { success: true, appointments },\r\n      { status: 200 }\r\n    );\r\n  } catch (error) {\r\n    console.error('Error fetching appointments:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}